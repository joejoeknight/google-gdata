Tip One:
One of the things that allways show up here on the newsgroups, is the problem to
figure out why an execution to the server failed. In general, this is rather
simplistic to deal with on the C# side, but as not everyone is familiar with the
process, here is the scoop.

When the webserver returns an error, an exception will be thrown. The C# client
code will catch this, package it into a GDataRequestException and throw that
one.

In the application code, therefore, when you do something like:

myFeed.Insert(myNewEntry);

what you should be doing is:


try { 
  myFeed.Insert(myNewEntry); 
} catch  (GDataRequestException e )  { 
// your error code here 
}


In general, the GDataRequestException class is just a  wrapper around the real
exception. It has the innerException, and it exposes the WebResponse, the object
that captures the server response, as a property named Response.

A WebResponse now has a bundle of properties, including a method
GetResponseStream, which you can use to get the real HTTP/Text that the server
returned. If you cast the WebResponse to an HttpWebResponse, you can get the
StatusCode and other, more HTTP specific information as well.

To make life easier, i just added a ResponseString property to the
GDataRequestException class, so that you can easier glance at additonal
information returned by the server. For those not at ease with the repository,
here is code that does the same in an exception handler:

catch (GDataRequestException e) { 
  Stream receiver = e.Response.GetResponseStream(); 
  if (receiver != null) { 
  // Pipe the stream to ahigher level stream reader with the default encoding 
  // format. which is UTF8 
  StreamReader readStream = new StreamReader(receiver);

  // Read 256 charcters at a time. 
  char []buffer = new char[256]; 
  StringBuilder builder = new StringBuilder(1024); 
  int count = readStream.Read( buffer, 0, 256); 
  while (count > 0) { 
    string onto the console. builder.Append(buffer); 
    count = readStream.Read(buffer,0, 256);
  }

  // Release the resources of stream object. 
  readStream.Close(); 
  receiver.Close();
  responseText = builder.ToString(); 
  }
}

At the end of the code, responseText will hold the complete HTTP/Text response
of the server. It might be safer to even check of the contenttype, before using
that string AS a string, but for debugging purposes this will do just fine.


Tip Two:
Understanding the Unknown

As you might have noticed, there are always new elements appearing in the atom
streams of properties, extensions that are useful to the individual property, 
and therefore, useful to at least some of the developers working with those 
properties. 

One example for this is the draft element in the beta.blogger.com feeds. The 
draft element is a subelement of an atom:entry, and looks pretty much like this:

<entry xmlns:app='http://purl.org/atom/app#'>
  ...
  <app:control>
    <app:draft>yes</app:draft>
  </app:control>
</entry>

What this does, for blogger, is, it marks this entry as a draft, as not yet 
finished. 

Now this is all well, but, if you are using a premade library to deal with 
the content, how do you suddenly insert a new element? You can obviously wait
for an updated release, that supports this new element. Or, you can do it 
yourself. 

For this, you need to understand a little bit about the way the current parser 
works. The parser is based on XmlReader, not the XmlDom, and parses the stream
using the XmlReader interfaces to encounter all the Atom/GData elements. For
things the parser understands, he creates the corresponding objects, like 
AtomEntry, and fills the properties of that object. 

But what happens with things that are not understood? They end up as an element 
of the ExtensionElements collection, that is a member of all classes inherited 
from AtomBase, like AtomFeed, AtomEntry, EventEntry etc... 

That means for something like a blogger entry that would have an app:control 
element in it, that this xml snippet is not lost. It's only not directly exposed 
as a property, but, instead, converted into an XmlNode and then put into 
the ExtensionElements collection. 

This can actually be intercepted, by hooking the FeedParserEventHandler (which
fires events when new elements are created) and the ExtensionElementEventHandler
(which fires events when unknown entities are encountered). By intercepting and
overriding the default behaviour you are able to substitute your own objects 
for the default objects created. This is the way the CalendarFeed/EventEntry
are implemented, and all other extensions as well.

But, this is a more advanced topic for another time. Back to the ExtensionElments
collection. Everything in that collection is potentially persisted. If it is an
XmlNode object, or if it is inheriting from IExtensionElement, it will be saved 
into the xml stream when it's owner is persisted.

Hence to figure out if a certain attribute is set you can do something like this:

    foreach (Object obj in entry.ExtensionElements) 
      if obj is XmlNode
         ... check whatever it is you are looking for
      
      
        
If also means that the following code:

     XmlNode node = new XmlNode(
              "<app:control xmlns:app='http://purl.org/atom/app#>
                <app:draft>yes</app:draft>
              </app:control>"
              
      AtomEntry entry = .... 
      entry.ExtensionElements.Add(node);
      
      entry.Update();
      
 will create the required xml during the update/insert process to indicate
 this to be a draft element. 
 
 Hope that was helpful.


Tip Three:

One of the new features in the Google Calendar service is the ability to embed web content
in the UI (see here: http://googleblog.blogspot.com/2006/09/google-calendar-does-something-about.html).

Essentially, what you need to do is to create an atom:link, with a gcal:webContent 
child element of the following form:

<atom:link rel="http://schemas.google.com/gCal/2005/webContent"
           title="Your Title"
           href="a link to an icon for the top of the day">
           type="text/html or image/*"
  <gCal:webContent url="a link to the content"
                   width="pixels"
                   height="pixels" />
</atom:link>

If type is text/html, the content will be displayed in an IFrame, if it's image/*, an IMG 
element will be used.

There is samplecode in cs/src/unittests/caltest.cs, here is the relevant part to show you how easy it is to set this up:                   
                   
                    EventEntry entry = ...

                    AtomLink link = new AtomLink("image/gif", "http://schemas.google.com/gCal/2005/webContent");
                    link.Title = "Test content";
                    link.HRef = "http://www.google.com/calendar/images/google-holiday.gif";
                    WebContent content = new WebContent();
                    content.Url = "http://www.google.com/logos/july4th06.gif";
                    content.Width = 270;
                    content.Height = 130;
                    link.ExtensionElements.Add(content);
                    entry.Links.Add(link);

                    entry.Update(..

That's it. Play with it and enjoy the visual effects you can create for your calendar that way.







 
 
        
             